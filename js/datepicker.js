import Base from './base'
import Renderer from './renderer'
import EventManager from './eventManager'
import DateArray from './util/dateArray'
import DateRangePicker from './dateRangePicker'
import {JQUERY_NAME, DATA_KEY, Event, Selector, ClassName, Unit, View} from './constants'
import Popper from 'popper.js'
import moment from 'moment'
import {main} from './templates'

/**
 * Datepicker for fields using momentjs for all date-based functionality.
 *
 * Internal dates are stored as UTC moments.  To use them in local time, execute moment.local() prior to formatting.
 */
const Datepicker = (($) => {

  const JQUERY_NO_CONFLICT = $.fn[JQUERY_NAME]
  const Default = {
    // lang defaults to en, most i18n comes from moment's locales.
    lang: 'en',
    // i18n - for the very few strings we use.
    i18n: {
      en: {
        today: 'Today',
        clear: 'Clear'
      }
    },

    autoclose: false, // Whether or not to close the datepicker immediately when a date is selected
    toggleActive: false, // If true, selecting the currently active date in the datepicker will unset the respective date. This option is always true when the multidate option is being used
    forceParse: true, // force parsing of the input value when the picker is closed. That is, when an invalid date is left in the input field by the user, the picker will forcibly parse that value, and set the input’s value to the new, valid date, conforming to the given format.
    keyboard: {
      navigation: true, // allow date navigation by arrow keys
      touch: true // false will disable keyboard on mobile devices
    },
    rtl: false,
    enableOnReadonly: true, // If false the datepicker will not show on a readonly datepicker field
    showOnFocus: true, // If false, the datepicker will be prevented from showing when the input field associated with it receives focus
    zIndexOffset: 10, // z-index of the open datepicker is the maximum z-index of the input and all of its DOM ancestors plus the zIndexOffset.
    container: 'body',
    immediateUpdates: false, // if true, selecting a year or month in the datepicker will update the input value immediately. Otherwise, only selecting a day of the month will update the input value immediately.
    title: '', // string that will appear on top of the datepicker. If empty the title will be hidden.
    today: {
      button: false, // If true or “linked”, displays a “Today” button at the bottom of the datepicker to select the current date. If true, the “Today” button will only move the current date into view if “linked”, the current date will also be selected.
      highlight: false // If true, highlights the current date.
    },

    //-----------------
    // view types:
    //    days(0) | months(1) | years(2) | decades(3) | centuries(4)
    view: {
      start: 'days', // The view that the datepicker should show when it is opened - string or digit
      min: 'days', // Set a minimum limit for the view mode
      max: 'centuries', // Set a maximum limit for the view mode
      modes: [
        {
          cssClass: ClassName.DAYS,
          navStep: 1
        },
        {
          cssClass: ClassName.MONTHS,
          navStep: 1
        },
        {
          cssClass: ClassName.YEARS,
          navStep: 10
        },
        {
          cssClass: ClassName.DECADES,
          navStep: 100
        },
        {
          cssClass: ClassName.CENTURIES,
          navStep: 1000
        }]
    },
    // ----------------
    // multi-dates
    //
    multidate: {
      // Enable multidate picking. Each date in month view acts as a toggle button, keeping track of which dates the user has selected in order. If a number is given, the picker will limit how many dates can be selected to that number, dropping the oldest dates from the list when the number is exceeded. true equates to no limit. The input’s value (if present) is set to a string generated by joining the dates, formatted, with multidate.separator
      enabled: false,
      // The string that will appear between dates when generating the input’s value. When parsing the input’s value for a multidate picker, this will also be used to split the incoming string to separate multiple formatted dates as such, it is highly recommended that you not use a string that could be a substring of a formatted date (eg, using ‘-‘ to separate dates when your format is ‘yyyy-mm-dd’).
      separator: ','
    },
    week: {
      start: 0 // Day of the week start. 0 (Sunday) to 6 (Saturday)
      // end is calculated based on start
    },
    // format: // pass in a momentjs compatible format, or it will default to L based on locale
    date: {
      //start: default: beginning of time - The earliest date that may be selected all earlier dates will be disabled.
      //end:  default: end of time - The latest date that may be selected all later dates will be disabled
      disabled: [] // Single or Array of disabled dates - can be string or moment
      //'default': // default is today - can be a string or a moment
    },
    daysOfWeek: {
      // Values are 0 (Sunday) to 6 (Saturday)
      disabled: [],   // Days of the week that should be disabled. Example: disable weekends: [0,6]
      highlighted: [] // Days of the week that should be highlighted. Example: highlight weekends: [0,6].
    },

    // Popper.js options - see https://popper.js.org/
    popper: {
      // any popper.js options are valid here and will be passed to that component
      placement: 'right'
    },

    template: main,

    // -------------------
    // callbacks  FIXME: better way to do this?

    /*
     A function that takes a date as a parameter and returns one of the following values:

     - undefined to have no effect
     - An object with the following properties:
     selectable: A Boolean, indicating whether or not this date is selectable
     classes: A String representing additional CSS classes to apply to the date’s cell
     tooltip: A tooltip to apply to this date, via the title HTML attribute
     */
    beforeShowDay: undefined,
    beforeShowMonth: undefined,
    beforeShowYear: undefined,
    beforeShowDecade: undefined,
    beforeShowCentury: undefined
  }

  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   * TODO: break this into components - ConfigurationManager(? not sure on this one), DateManager, EventManager, Renderer?
   */
  class Datepicker extends Base {

    constructor($element, ...configs) {
      super(Default, ...configs)

      this.$element = $element
      this.shown = false
      this.dates = new DateArray()

      // get our own utc instance and configure the locale
      this.moment = this.newMoment()

      // disallow updates during setup, call after
      this.allowUpdate = false

      // normalize options that are flexible
      this.normalizeConfig()

      //
      this.view = this.config.view.start
      this.viewDate = this.config.date.default
      this.focusDate = null

      // inline datepicker if target is a div
      this.isInline = this.$element.is('div')

      // find the $input right now
      if (this.$element.is('input')) {
        this.$input = this.$element
      }
      else if (this.component) {
        this.$input = this.$element.find('input')
      }

      // FIXME: data-datepicker-toggle='#input-id' or whatever pattern bootstrap uses for toggle - `click: () => this.show()` instead of old `component` or add-on

      // initialize the renderer and create the $picker element
      this.renderer = new Renderer(this)


      // initialize the EventManager
      this.eventManager = new EventManager(this)

      // turn back on updates
      this.allowUpdate = true
      this.update()
      this.showView()

      if (this.isInline) {
        this.show()
      }
    }

    dispose(dataKey = DATA_KEY) {
      this.hide()
      this.eventManager.dispose()
      this.renderer.dispose()
      this.renderer = undefined
      this.popper = undefined
      super.dispose(dataKey)
    }

    /**
     * @returns a new UTC moment configured with the locale
     */
    newMoment(...args) {
      let m = null

      if (args.length < 1) {
        // if no args, use the current date/time (cannot pass in null otherwise time is zeroed)
        m = moment()
      }
      else {
        m = moment(args)
      }

      m.utc()
      m.locale(this.config.lang)
      return m
    }

    /**
     * @returns the lower date limit on the datepicker.
     */
    getDateStart() {
      return this.config.date.start
    }


    /**
     * @returns the upper date limit on the datepicker
     */
    getDateEnd() {
      return this.config.date.end
    }

    /**
     * For use with multidate pickers.
     * @returns - array of UTC moments representing the internal date objects of the first datepicker in the selection.
     */
    getDates() {
      return this.dates.clonedArray()
    }

    /**
     * For multidate pickers, returns the latest date selected.
     * @returns - the latest UTC moment selected of the first datepicker in the selection.
     */
    getDate() {
      let m = this.dates.last()
      if (typeof m !== 'undefined') {
        return m.clone()
      }
      else {
        return null
      }
    }

    /**
     * Sets the internal date list. For use with multidate pickers.
     * @param dates - one or more String|moment - will be converted to UTC
     * @returns {Datepicker}
     */
    setDates(...dates) {
      this.update(...dates)
      return this
    }

    /**
     * @see #setDates
     * @param date
     */
    setDate(date) {
      this.setDates(date)
    }

    /**
     * Sets a new lower date limit on the datepicker.
     * Omit (or provide an otherwise falsey value) to unset the limit.
     * @param dateStart
     * @returns {Datepicker}
     */
    setDateStart(dateStart) {
      if (dateStart) {
        // verify/reparse
        this.config.date.start = this.parseDate(dateStart)
      }
      else {
        // default to beginning of time
        this.config.date.start = this.startOfAllTime()
      }
      // called from #normalizeConfig
      this.update()
      return this
    }

    /**
     * Sets a new upper date limit on the datepicker.
     * Omit (or provide an otherwise falsey value) to unset the limit.
     * @param dateEnd
     * @returns {Datepicker}
     */
    setDateEnd(dateEnd) {

      if (dateEnd) {
        // verify/reparse
        this.config.date.end = this.parseDate(dateEnd)
      }
      else {
        // default to beginning of time
        this.config.date.end = this.endOfAllTime()
      }
      // called from #normalizeConfig
      this.update()
      return this
    }

    /**
     * Sets the days that should be disabled
     * Omit (or provide an otherwise falsey value) to unset.
     * @param dates - String|Moment|Array of String|Moment
     * @returns {Datepicker}
     */
    setDatesDisabled(dates) {
      let dateArray = dates
      // Disabled dates
      if (!Array.isArray(dateArray)) {
        dateArray = [dateArray]
      }

      let newDisabled = []
      for (let d of dateArray) {
        newDisabled.push(this.parseDate(d))
      }
      this.config.date.disabled = newDisabled
      // called from #normalizeConfig
      this.update()
      return this
    }

    /**
     * Sets the days of week that should be disabled.  See config.daysOfWeek.disabled
     * Omit (or provide an otherwise falsey value) to unset.
     * @param days
     * @returns {Datepicker}
     */
    setDaysOfWeekDisabled(days) {
      this.config.daysOfWeek.disabled = days
      this.normalizeConfig()
      this.update()
      return this
    }

    /**
     * Sets the days of week that should be highlighted. See config.daysOfWeek.highlighted
     * Omit (or provide an otherwise falsey value) to unset.
     * @param days
     * @returns {Datepicker}
     */
    setDaysOfWeekHighlighted(days) {
      this.config.daysOfWeek.highlighted = days
      this.normalizeConfig()
      this.update()
      return this
    }

    // ------------------------------------------------------------------------
    // protected

    /**
     *
     * @param range - a {DateRange} from moment-range - provide a falsey value to unset
     */
    setRange(range) {
      this.range = range
      this.renderer.fill();
    }

    // ------------------------------------------------------------------------
    // private
    showView(dir) {
      if (dir) {
        this.view = Math.max(this.config.view.min, Math.min(this.config.view.max, this.view + dir))
      }
      this.renderer.$picker
        .children('div')
        .hide()
        .filter(`.${this.config.view.modes[this.view].cssClass}`) // days|months|years|decades|centuries
        .show()
      this.renderer.updateNavArrows()  // FIXME: redundant?
    }


    /**
     *
     * @param date - start date
     * @param dir - direction/number of units
     * @param unit - day|month|year etc to use with moment#add
     * @returns {*}
     */
    moveAvailableDate(date, dir, unit) {
      let m = date.clone()
      do {
        m = m.add(dir, unit)
        //m = this[fn](m, dir)

        if (!this.dateWithinRange(m))
          return false

        unit = Unit.DAY
      }
      while (this.dateIsDisabled(m))

      return m
    }


    toggleMultidate(date) {
      var index = this.dates.contains(date)
      if (!date) {
        this.dates.clear()
      }

      if (index !== -1) {
        if (this.config.multidate.enabled === true || this.config.multidate.enabled > 1 || this.config.toggleActive) {
          this.dates.remove(index)
        }
      }
      else if (this.config.multidate.enabled === false) {
        this.dates.clear()
        this.dates.push(date)
      }
      else {
        this.dates.push(date)
      }

      if (typeof this.config.multidate.enabled === 'number')
        while (this.dates.length() > this.config.multidate.enabled)
          this.dates.remove(0)
    }

    // FIXME: this was called _setDate - WHY? different than #setDate, can this use setDate?
    clickDate(date, which) {
      if (!which || which === 'date') {
        this.toggleMultidate(date)
      }
      if (!which || which === 'view') {
        this.viewDate = date
      }

      this.renderer.fill()
      this.setInputValue()
      if (!which || which !== 'view') {
        this.eventManager.trigger(Event.DATE_CHANGE)
      }

      this.$input.change()
      if (this.config.autoclose && (!which || which === 'date')) {
        this.hide()
      }
    }

    isShowing() {
      return this.shown
    }

    //
    show() {
      if (this.isInline || this.isShowing()) {
        return
      }

      if (this.$input.attr('readonly') && this.config.enableOnReadonly === false) {
        return
      }

      // popper
      this.popper = new Popper(this.$element, {contentType: 'node', content: this.renderer.$picker}, this.config.popper)
      this.shown = true

      this.eventManager.onShown()
      return this
    }

    //isPickerVisible() {
    //  return this.renderer.$picker.is(':visible')
    //}

    hide() {
      if (this.isInline || !this.isShowing()) {
        return this
      }

      this.focusDate = null

      if (!this.popper) {
        return
      }

      // popper
      this.popper.destroy()
      this.popper._popper.parentNode.removeChild(this.popper._popper) // workaround for failure to destroy https://github.com/FezVrasta/popper.js/issues/30
      this.popper = undefined
      this.shown = false

      this.eventManager.onHidden()
      this.view = this.config.view.start
      this.showView()

      if (this.config.forceParse && this.$input.val()) {
        this.setInputValue()
      }
      return this
    }

    normalizeConfig() {
      // disallow updates - must call #update after
      let originalAllowUpdate = this.allowUpdate
      this.allowUpdate = false

      // Normalize views as view-type integers
      this.config.view.start = this.resolveViewType(this.config.view.start)
      this.config.view.min = this.resolveViewType(this.config.view.min)
      this.config.view.max = this.resolveViewType(this.config.view.max, View.YEARS) // default to years (slightly different than other view resolution)

      // Check that the start view is between min and max
      this.config.view.start = Math.min(this.config.view.start, this.config.view.max)
      this.config.view.start = Math.max(this.config.view.start, this.config.view.min)

      // Multi-dates
      // true, false, or Number > 0
      if (this.config.multidate.enabled !== true) {
        this.config.multidate.enabled = Number(this.config.multidate.enabled) || false
        if (this.config.multidate.enabled !== false)
          this.config.multidate.enabled = Math.max(0, this.config.multidate.enabled)
      }
      this.config.multidate.separator = String(this.config.multidate.separator)

      // Week
      this.config.week.start %= 7
      this.config.week.end = (this.config.week.start + 6) % 7

      // Format - setup the format or default to a momentjs format
      this.config.format = this.config.format || this.moment.localeData().longDateFormat('L')

      // Start/End or Min/max dates
      this.setDateStart(this.config.date.start)
      this.setDateEnd(this.config.date.end)
      this.setDatesDisabled(this.config.date.disabled)

      // Default date - if unspecified, it is now
      this.config.date.default = this.config.date.default || this.moment.clone()

      // restore allowUpdate
      this.allowUpdate = originalAllowUpdate
    }

    formatDate(mom, format = this.config.format) {
      return mom.format(format)
    }

    parseDates(...dates) {
      //if(!dates || dates.length < 1){
      //  return []
      //}

      let results = []
      for (let date of dates) {
        if (date) {
          results.push(this.parseDate(date))
        }
      }
      return results
    }

    parseDate(value, format = this.config.format) {
      // @see http://momentjs.com/docs/#/parsing/

      // return any current moment
      if (moment.isMoment(value)) {
        if (!value.isValid()) {
          this.throwError(`Invalid moment: ${value} provided.`)
        }

        return this.newMoment(value)
      }
      else if (typeof value === "string") {
        // parse with locale and strictness
        let m = moment(value, format, this.config.lang, true)

        if (!m.isValid()) {
          this.throwError(`Invalid moment: ${value} for format: ${format} and locale: ${this.config.lang}`)
        }

        return m
      }
      else {
        this.throwError(`Unknown value type ${typeof value} for value: ${this.dump(value)}`)
      }
    }

    shouldBeHighlighted(date) {
      return $.inArray(date.day(), this.config.daysOfWeek.highlighted) !== -1
    }

    weekOfDateIsDisabled(date) {
      return $.inArray(date.day(), this.config.daysOfWeek.disabled) !== -1
    }

    dateIsDisabled(date) {
      return (
        this.weekOfDateIsDisabled(date) ||
        $.grep(this.config.date.disabled,
          (d) => {
            return date.isSame(d, Unit.DAY)
          }
        ).length > 0
      )
    }

    dateWithinRange(date) {
      return date.isSameOrAfter(this.config.date.start) && date.isSameOrBefore(this.config.date.end)
    }

    startOfDay(moment = this.moment) {
      return moment.clone().startOf(Unit.DAY)
    }

    startOfAllTime(moment = this.moment) {
      return moment.clone().startOf(Unit.YEAR).year(0)
    }

    endOfAllTime(moment = this.moment) {
      return moment.clone().endOf(Unit.YEAR).year(2200) // ?? better value to set for this?
    }

    resolveViewType(view, defaultValue = View.DAYS) {
      if (typeof view === 'string') {
        let value = null
        switch (view) {
          case 'days':
            value = View.DAYS
            break
          case 'months':
            value = View.MONTHS
            break
          case 'years':
            value = View.YEARS
            break
          default:
            value = defaultValue
            break
        }
        return value
      }
      else {
        return view
      }
    }

    clearDates() {
      this.$input.val('')

      this.update()
      this.eventManager.trigger(Event.DATE_CHANGE)

      if (this.config.autoclose) {
        this.hide()
      }
    }


    /**
     *
     * @param date - one or more - String|moment - optional
     * @returns {Datepicker}
     */
    update(...moments) {
      if (!this.allowUpdate) {
        return this
      }

      let oldDates = this.dates.copy()
      this.dates = this.resolveDates(...moments)
      this.resolveViewDate()

      if (moments) {
        // args passed means setting date by clicking?  FIXME: how about making this more explicit?
        this.setInputValue()
      }
      else if (this.dates.length()) {
        // setting date by typing
        if (String(oldDates.array) !== String(this.dates.array))
          this.eventManager.trigger(Event.DATE_CHANGE)
      }
      if (!this.dates.length() && oldDates.length()) {
        this.eventManager.trigger(Event.DATE_CLEAR)
      }

      this.renderer.fill()
      this.$element.change()
      return this
    }

    setInputValue() {
      let formatted = this.getDateFormatted()
      this.$input.val(formatted)
      return this
    }

    getDateFormatted(format = this.config.format) {
      return this.dates.formattedArray(format).join(this.config.multidate.separator)
    }

    resolveViewDate() {
      if (this.dates.length()) {
        this.viewDate = this.dates.last().clone()
      }
      else if (this.viewDate < this.config.date.start) {
        this.viewDate = this.config.date.start.clone()
      }
      else if (this.viewDate > this.config.date.end) {
        this.viewDate = this.config.date.end.clone()
      }
      else {
        this.viewDate = this.config.date.default.clone()
      }
    }

    /**
     * resolve a new {DateArray}
     *
     * @param dates
     * @returns {DateArray}
     */
    resolveDates(...dates) {
      let newDatesArray = null
      if (dates) {
        newDatesArray = this.parseDates(...dates)
      }
      else {
        newDatesArray = this.$input.val()

        if (newDatesArray && this.config.multidate.enabled) {
          newDatesArray = newDatesArray.split(this.config.multidate.separator)
        }
        else {
          newDatesArray = [newDatesArray]
        }
        //delete this.$element.data().date
        newDatesArray = this.parseDates(...newDatesArray)
      }

      newDatesArray = $.grep(newDatesArray, (date) => {
        return (!this.dateWithinRange(date) || !date)
      }, true)

      return new DateArray(...newDatesArray)
    }


    // ------------------------------------------------------------------------
    // static
    static _jQueryInterface(config) {
      //let methodResult = undefined
      return this.each(
        function () {
          let $element = $(this)
          let data = $element.data(DATA_KEY)
          // Options priority: js args, data-attrs, Default const
          let _config = $.extend(
            {},
            Default,
            $element.data(),
            typeof config === 'object' && config  // config could be a string method name.
          )

          // instantiate a Datepicker or a DateRangePicker
          if (!data) {
            // FIXME: I really think this should be encapsulated in DateRangePicker, and not here.
            if ($element.hasClass('input-daterange') || _config.inputs) {
              data = new DateRangePicker($element,
                $.extend(_config, {inputs: _config.inputs || $element.find('input').toArray()})
              )
            }
            else {
              data = new Datepicker($element, _config)
            }
            $element.data(DATA_KEY, data)
          }

          // call public methods jquery style
          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error(`No method named "${config}"`)
            }
            //methodResult =
            data[config]()
          }
        }
      )

      //if (methodResult !== undefined) {
      //  // return method result if there is one
      //  return methodResult
      //}
      //else {
      //  // return the element
      //  return this
      //}
    }
  }

  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */
  $(document).on(Event.CLICK_DATA_API, Selector.DATA_PROVIDE, function (event) {
    event.preventDefault()
    Datepicker._jQueryInterface.call(this, 'show')
  })

  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */
  $.fn[JQUERY_NAME] = Datepicker._jQueryInterface
  $.fn[JQUERY_NAME].Constructor = Datepicker
  $.fn[JQUERY_NAME].noConflict = () => {
    $.fn[JQUERY_NAME] = JQUERY_NO_CONFLICT
    return Datepicker._jQueryInterface
  }

  return Datepicker

})(jQuery)

export default Datepicker
