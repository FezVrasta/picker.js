import Base from './base'
import moment from 'moment'
import {main} from './templates'
import Keycodes from './util/keycodes'
import Key from './util/key'
import Dates from './util/dates'

/**
 * Datepicker for fields using momentjs for all date-based functionality.
 *
 * Internal dates are stored as UTC moments.  To use them in local time, execute moment.local() prior to formatting.
 */
const Datepicker = (($) => {

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  const NAME = 'datepicker'
  const DATA_KEY = `bmd.${NAME}`
  const EVENT_KEY = `.${DATA_KEY}`
  const DATA_API_KEY = '.data-api'
  const JQUERY_NAME = `bmd${NAME.charAt(0).toUpperCase() + NAME.slice(1)}`
  const JQUERY_NO_CONFLICT = $.fn[JQUERY_NAME]

  const Event = {
    //  SHOW           : `show${EVENT_KEY}`,
    //  SHOWN          : `shown${EVENT_KEY}`,
    //  HIDE           : `hide${EVENT_KEY}`,
    //  HIDDEN         : `hidden${EVENT_KEY}`,
    CLICK_DATA_API: `click${EVENT_KEY}${DATA_API_KEY}`
  }

  const Default = {
    lang: 'en',
    autoclose: false, // Whether or not to close the datepicker immediately when a date is selected
    toggleActive: false, // If true, selecting the currently active date in the datepicker will unset the respective date. This option is always true when the multidate option is being used
    forceParse: true, // force parsing of the input value when the picker is closed. That is, when an invalid date is left in the input field by the user, the picker will forcibly parse that value, and set the input’s value to the new, valid date, conforming to the given format.
    keyboard: {
      navigation: true, // allow date navigation by arrow keys
      touch: true // false will disable keyboard on mobile devices
    },
    rtl: false,
    enableOnReadonly: true, // If false the datepicker will not show on a readonly datepicker field
    showOnFocus: true, // If false, the datepicker will be prevented from showing when the input field associated with it receives focus
    zIndexOffset: 10, // z-index of the open datepicker is the maximum z-index of the input and all of its DOM ancestors plus the zIndexOffset.
    container: 'body',
    immediateUpdates: false, // if true, selecting a year or month in the datepicker will update the input value immediately. Otherwise, only selecting a day of the month will update the input value immediately.
    title: '', // string that will appear on top of the datepicker. If empty the title will be hidden.
    today: {
      button: false, // If true or “linked”, displays a “Today” button at the bottom of the datepicker to select the current date. If true, the “Today” button will only move the current date into view if “linked”, the current date will also be selected.
      highlight: false, // If true, highlights the current date.
    },

    //-----------------
    // view types:
    //    days(0) | months(1) | years(2) | decades(3) | centuries(4)
    view: {
      start: 'days', // The view that the datepicker should show when it is opened - string or digit
      min: 'days', // Set a minimum limit for the view mode
      max: 'centuries' // Set a maximum limit for the view mode
    },
    // ----------------
    // multi-dates
    //
    multidate: {
      // Enable multidate picking. Each date in month view acts as a toggle button, keeping track of which dates the user has selected in order. If a number is given, the picker will limit how many dates can be selected to that number, dropping the oldest dates from the list when the number is exceeded. true equates to no limit. The input’s value (if present) is set to a string generated by joining the dates, formatted, with multidate.separator
      enabled: false,
      // The string that will appear between dates when generating the input’s value. When parsing the input’s value for a multidate picker, this will also be used to split the incoming string to separate multiple formatted dates as such, it is highly recommended that you not use a string that could be a substring of a formatted date (eg, using ‘-‘ to separate dates when your format is ‘yyyy-mm-dd’).
      separator: ','
    },
    week: {
      start: 0 // Day of the week start. 0 (Sunday) to 6 (Saturday)
      // end is calculated based on start
    },
    // format: // pass in a momentjs compatible format, or it will default to L based on locale
    date: {
      //start: default: beginning of time - The earliest date that may be selected all earlier dates will be disabled.
      //end:  default: end of time - The latest date that may be selected all later dates will be disabled
      disabled: [] // Single or Array of disabled dates - can be string or moment
      //'default': // default is today - can be a string or a moment
    },
    daysOfWeek: {
      // Values are 0 (Sunday) to 6 (Saturday)
      disabled: [],   // Days of the week that should be disabled. Example: disable weekends: [0,6]
      highlighted: [] // Days of the week that should be highlighted. Example: highlight weekends: [0,6].
    },
    // Popper.js options - see https://popper.js.org/
    popper: {
      // any popper.js options are valid here and will be passed to that component
    },
    template: main
  }

  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */
  class Datepicker extends Base {

    constructor($element, ...configs) {
      super($element, Default, ...configs)

      this.dates = new Dates()

      // get our own utc instance and configure the locale
      this.moment = moment().utc().locale(this.config.lang)

      // normalize options that are flexible
      this.normalizeConfig()

      //
      this.viewDate = this.config.date.default
      this.focusDate = null

      // inline datepicker if target is a div
      this.isInline = this.$element.is('div')
      this.isInput = this.$element.is('input')

      // component
      this.component = this.$element.hasClass('date') ? this.$element.find('.add-on, .input-group-addon, .btn') : false
      this.hasInput = this.component && this.$element.find('input').length
      if (this.component && this.component.length === 0)
        this.component = false

      //
      this.$picker = $(this.config.template)

      //
      this.events = []
      this.secondaryEvents = []

      this.buildEvents()
    }

    dispose(dataKey = DATA_KEY) {
      super.dispose(dataKey)
    }


    // ------------------------------------------------------------------------
    // protected

    // ------------------------------------------------------------------------
    // private
    buildEvents() {
      let events = {
        keyup: (ev) => this.keyup(ev),
        keydown: (ev) => this.keydown(ev),
        paste: (ev) => this.paste(ev)
      }

      if (this.config.showOnFocus === true) {
        events.focus = () => this.show()
      }

      if (this.isInput) { // single input
        this.events = [
          [this.$element, events]
        ]
      }
      else if (this.component && this.hasInput) { // component: input + button
        this.events = [
          // For components that are not readonly, allow keyboard nav
          [this.$element.find('input'), events],
          [this.component, {
            click: () => this.show()
          }]
        ]
      }
      else if (this.isInline) {  // inline datepicker
        //this.isInline = true
        //       kross moved this to constructor
        // legacy, do we need to avoid else
      }
      else {
        this.events = [
          [this.$element, {
            click: () => this.show(),
            keydown: () => this.keydown()
          }]
        ]
      }
      this.events.push(
        // Component: listen for blur on element descendants
        [this.$element, '*', {
          blur: (ev) => {
            this._focused_from = ev.target
          }
        }],
        // Input: listen for blur on element
        [this.$element, {
          blur: (ev) => {
            this._focused_from = ev.target
          }
        }]
      )

      if (this.config.immediateUpdates) {
        // Trigger input updates immediately on changed year/month
        this.events.push([this.$element, {
          'changeYear changeMonth': (e) => {
            this.update(e.date)
          }
        }])
      }

      this.secondaryEvents = [
        [this.$picker, {
          click: () => this.click()
        }],
        [$(window), {
          resize: () => this.place()
        }],
        [$(document), {
          mousedown: (ev) => {
            // Clicked outside the datepicker, hide it
            if (!(
                this.$element.is(ev.target) ||
                this.$element.find(ev.target).length ||
                this.$picker.is(ev.target) ||
                this.$picker.find(ev.target).length ||
                this.$picker.hasClass('datepicker-inline')
              )) {
              this.hide()
            }
          }
        }]
      ]
    }

    // FIXME: nomenclature to be onKe*
    keyup(ev) {
      if (Key.isNot(ev,
          Keycodes.ESC,
          Keycodes.LEFT,
          Keycodes.RIGHT,
          Keycodes.UP,
          Keycodes.DOWN,
          Keycodes.SPACE,
          Keycodes.ENTER,
          Keycodes.TAB))
        this.update()
    }

    // FIXME: nomenclature to be onKe*
    keydown(ev) {
      if (!this.$picker.is(':visible')) {
        if (Key.is(ev, Keycodes.DOWN, Keycodes.ESC)) { // allow down to re-show picker
          this.show()
          ev.stopPropagation()
        }
        return
      }
      let dateChanged = false
      let dir = null
      let newViewDate = null
      let focusDate = this.focusDate || this.viewDate

      switch (ev.keyCode) {
        case Keycodes.ESC:
          if (this.focusDate) {
            this.focusDate = null
            this.viewDate = this.dates.last() || this.viewDate
            this.fill()
          }
          else
            this.hide()
          ev.preventDefault()
          ev.stopPropagation()
          break
        case Keycodes.LEFT:
        case Keycodes.UP:
        case Keycodes.RIGHT:
        case Keycodes.DOWN:
          if (!this.config.keyboard.navigation || this.config.daysOfWeek.disabled.length === 7)
            break
          dir = Key.is(ev, Keycodes.LEFT, Keycodes.UP) ? -1 : 1
          if (this.viewMode === 0) {
            if (ev.ctrlKey) {
              newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear')

              if (newViewDate)
                this._trigger('changeYear', this.viewDate)
            }
            else if (ev.shiftKey) {
              newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth')

              if (newViewDate)
                this._trigger('changeMonth', this.viewDate)
            }
            else if (Key.is(ev, Keycodes.LEFT, Keycodes.RIGHT)) {
              newViewDate = this.moveAvailableDate(focusDate, dir, 'moveDay')
            }
            else if (!this.weekOfDateIsDisabled(focusDate)) {
              newViewDate = this.moveAvailableDate(focusDate, dir, 'moveWeek')
            }
          }
          else if (this.viewMode === 1) {
            if (Key.is(ev, Keycodes.UP, Keycodes.DOWN)) {
              dir = dir * 4
            }
            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth')
          }
          else if (this.viewMode === 2) {
            if (Key.is(ev, Keycodes.UP, Keycodes.DOWN)) {
              dir = dir * 4
            }
            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear')
          }
          if (newViewDate) {
            this.focusDate = this.viewDate = newViewDate
            this.setInputValue()
            this.fill()
            ev.preventDefault()
          }
          break
        case Keycodes.ENTER:
          if (!this.config.forceParse)
            break
          focusDate = this.focusDate || this.dates.last() || this.viewDate
          if (this.config.keyboard.navigation) {
            this._toggle_multidate(focusDate)
            dateChanged = true
          }
          this.focusDate = null
          this.viewDate = this.dates.last() || this.viewDate
          this.setInputValue()
          this.fill()
          if (this.$picker.is(':visible')) {
            ev.preventDefault()
            ev.stopPropagation()
            if (this.config.autoclose)
              this.hide()
          }
          break
        case Keycodes.TAB:
          this.focusDate = null
          this.viewDate = this.dates.last() || this.viewDate
          this.fill()
          this.hide()
          break
      }
      if (dateChanged) {
        if (this.dates.length())
          this._trigger('changeDate')
        else
          this._trigger('clearDate')
        let element
        if (this.isInput) {
          element = this.$element
        }
        else if (this.component) {
          element = this.$element.find('input')
        }
        if (element) {
          element.change()
        }
      }
    }

    //FIXME: normalize these signatures? to be the same as #trigger in Base class?
    _trigger(event, altdate) {
      let date = null
      if (altdate) {
        date = altdate.clone()
      }
      else {
        this.dates.last().clone()
      }

      super.trigger(event, {
        type: event,
        date: date,
        dates: this.dates.clonedArray()
      })
    }

    // FIXME: nomenclature to be onKe*
    paste(ev) {
      let dateString = null
      if (ev.originalEvent.clipboardData && ev.originalEvent.clipboardData.types
        && $.inArray('text/plain', ev.originalEvent.clipboardData.types) !== -1) {
        dateString = ev.originalEvent.clipboardData.getData('text/plain')
      }
      else if (window.clipboardData) {
        dateString = window.clipboardData.getData('Text')
      }
      else {
        return
      }
      this.setDate(dateString)
      ev.preventDefault()
    }

    //
    show() {
      let element = this.component ? this.$element.find('input') : this.$element
      if (element.attr('readonly') && this.config.enableOnReadonly === false)
        return
      if (!this.isInline)
        this.$picker.appendTo(this.config.container)
      this.place()
      this.$picker.show()
      this._attachSecondaryEvents()
      this._trigger('show')
      if ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && !this.config.keyboard.touch) {
        $(this.$element).blur()
      }
      return this
    }

    hide() {
      if (this.isInline)
        return this
      if (!this.$picker.is(':visible'))
        return this
      this.focusDate = null
      this.$picker.hide().detach()
      this._detachSecondaryEvents()
      this.viewMode = this.config.view.start
      this.showMode()

      if (
        this.config.forceParse &&
        (
          this.isInput && this.$element.val() ||
          this.hasInput && this.$element.find('input').val()
        )
      )
        this.setInputValue()
      this._trigger('hide')
      return this
    }

    normalizeConfig() {
      // Normalize views as view-type integers
      this.config.view.start = this.resolveViewType(this.config.view.start)
      this.config.view.min = this.resolveViewType(this.config.view.min)
      this.config.view.max = this.resolveViewType(this.config.view.max)

      // Check that the start view is between min and max
      this.config.view.start = Math.min(this.config.view.start, this.config.view.max)
      this.config.view.start = Math.max(this.config.view.start, this.config.view.min)

      // Multi-dates
      // true, false, or Number > 0
      if (this.config.multidate.enabled !== true) {
        this.config.multidate.enabled = Number(this.config.multidate.enabled) || false
        if (this.config.multidate.enabled !== false)
          this.config.multidate.enabled = Math.max(0, this.config.multidate.enabled)
      }
      this.config.multidate.separator = String(this.config.multidate.separator)

      // Week
      this.config.week.start %= 7
      this.config.week.end = (this.config.week.start + 6) % 7

      // Format - setup the format or default to a momentjs format
      this.config.format = this.config.format || this.moment.localeData().longDateFormat('L')

      // Start/End or Min/max dates
      this.setDateStart(this.config.date.start)
      this.setDateEnd(this.config.date.end)

      // Disabled dates
      if (!Array.isArray(this.config.date.disabled)) {
        this.config.date.disabled = [this.config.date.disabled]
      }

      let newDisabled = []
      for (let d of this.config.date.disabled) {
        newDisabled.push(this.parseDate(d))
      }
      this.config.date.disabled = newDisabled

      // Default date - if unspecified, it is now
      this.config.date.default = this.config.date.default || this.moment.clone()
    }

    formatDate(date, format = this.config.format) {
      date.format(this.config.format)
    }

    parseDate(value, format = this.config.format) {
      // @see http://momentjs.com/docs/#/parsing/

      // return any current moment
      if (moment.isMoment(value)) {
        if (!value.isValid()) {
          this.throwError(`Invalid moment: ${value} provided.`)
        }

        return this.moment.clone().moment(date)
      }
      else if (typeof value === "string") {
        // parse with locale and strictness
        let m = moment(value, format, this.config.lang, true)

        if (!m.isValid()) {
          this.throwError(`Invalid moment: ${value} for format: ${format} and locale: ${this.config.lang}`)
        }

        return m
      }
      else {
        this.throwError(`Unknown value type ${typeof value} for value: ${this.dump(value)}`)
      }
    }

    startOfDay(moment = this.moment) {
      return moment.clone().startOf('day')
    }

    startOfAllTime(moment = this.moment) {
      return moment.clone().startOf('year').year(0)
    }

    endOfAllTime(moment = this.moment) {
      return moment.clone().endOf('year').year(2200) // ?? better value to set for this?
    }

    resolveViewType(view) {
      if (typeof view === 'string') {
        let value = null
        switch (view) {
          case 'months':
            value = 1
            break
          case 'years':
            value = 2
            break
          default:
            value = 0
            break
        }
        return value
      }
      else {
        return view
      }
    }

    /**
     * @returns the lower date limit on the datepicker.
     */
    getDateStart() {
      return this.config.date.start
    }

    /**
     * Sets a new lower date limit on the datepicker.
     * Omit (or provide an otherwise falsey value) to unset the limit.
     * @param dateStart
     * @returns {Datepicker}
     */
    setDateStart(dateStart) {
      if (dateStart) {
        // verify/reparse
        this.config.date.start = this.parseDate(dateStart)
      }
      else {
        // default to beginning of time
        this.config.date.start = this.startOfAllTime()
      }

      this.update()
      return this
    }

    /**
     * @returns the upper date limit on the datepicker
     */
    getDateEnd() {
      return this.config.date.end
    }

    /**
     * Sets a new upper date limit on the datepicker.
     * Omit (or provide an otherwise falsey value) to unset the limit.
     * @param dateEnd
     * @returns {Datepicker}
     */
    setDateEnd(dateEnd) {

      if (dateEnd) {
        // verify/reparse
        this.config.date.end = this.parseDate(dateEnd)
      }
      else {
        // default to beginning of time
        this.config.date.end = this.endOfAllTime()
      }

      this.update()
      return this
    }

    /**
     * Sets the internal date list. For use with multidate pickers.
     * @param dates - one or more String|moment - will be converted to UTC
     * @returns {Datepicker}
     */
    setDates(...dates) {
      this.update(...dates);
      return this;
    }

    /**
     * @see #setDates
     * @param date
     */
    setDate(date) {
      this.setDates(date)
    }

    /**
     *
     * @param date - one or more - String|moment - optional
     * @returns {Datepicker}
     */
    update(...dates) {
      if (!this.allowUpdate) {
        return this
      }

      let oldDates = this.dates.copy()
      this.dates = this.resolveDates(...dates)
      this.resolveViewDate()

      if (dates) {
        // args passed means setting date by clicking?  FIXME: how about making this more explicit?
        this.setInputValue()
      }
      else if (this.dates.length()) {
        // setting date by typing
        if (String(oldDates.array) !== String(this.dates.array))
          this._trigger('changeDate')
      }
      if (!this.dates.length() && oldDates.length()) {
        this._trigger('clearDate')
      }

      this.fill()
      this.$element.change()
      this.updateNavArrows()
      return this
    }

    setInputValue() {
      var formatted = this.getDateFormatted();
      if (!this.isInput) {
        if (this.component) {
          this.$element.find('input').val(formatted);  // FIXME: find $input in constructor and replace a bunch of these?
        }
      }
      else {
        this.$element.val(formatted);
      }
      return this;
    }

    getDateFormatted(format = this.config.format) {
      return this.dates.formattedArray(format).join(this.config.multidate.separator);
    }

    resolveViewDate() {
      if (this.dates.length()) {
        this.viewDate = this.dates.last().clone()
      }
      else if (this.viewDate < this.config.date.start) {
        this.viewDate = this.config.date.start.clone()
      }
      else if (this.viewDate > this.config.date.end) {
        this.viewDate = this.config.date.end.clone()
      }
      else {
        this.viewDate = config.date.default.clone()
      }
    }

    /**
     * Whether passed in or discovered from the element, resolve a new {Dates}
     *
     * @param dates
     * @returns {Dates}
     */
    resolveDates(...dates) {
      let newDatesArray = null
      let fromArgs = false
      if (dates) {
        newDatesArray = []
        for (let date of dates) {
          newDatesArray.push(this.parseDate(date))
        }
      }
      else {
        if (this.isInput) {
          newDatesArray = this.$element.val()
        }
        else {
          newDatesArray = this.$element.data('date') || this.$element.find('input').val()
        }

        if (newDatesArray && this.config.multidate.enabled)
          newDatesArray = newDatesArray.split(this.config.multidate.separator)
        else
          newDatesArray = [newDatesArray]
        delete this.$element.data().date
      }

      newDatesArray = $.map(newDatesArray, $.proxy(function (date) {
        return DPGlobal.parseDate(date, this.config.format, this.config.language, this.config.assumeNearbyYear)
      }, this))
      newDatesArray = $.grep(newDatesArray, $.proxy(function (date) {
        return (
          !this.dateWithinRange(date) || !date
        )
      }, this), true)

      return new Dates(newDatesArray)
    }


    // ------------------------------------------------------------------------
    // static
    static _jQueryInterface(config) {
      return this.each(function () {
        let $element = $(this)
        let data = $element.data(DATA_KEY)

        if (!data) {
          data = new Datepicker($element, config)
          $element.data(DATA_KEY, data)
        }
      })
    }
  }

  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */
  $.fn[JQUERY_NAME] = Datepicker._jQueryInterface
  $.fn[JQUERY_NAME].Constructor = Datepicker
  $.fn[JQUERY_NAME].noConflict = () => {
    $.fn[JQUERY_NAME] = JQUERY_NO_CONFLICT
    return Datepicker._jQueryInterface
  }

  return Datepicker

})(jQuery)

export default Datepicker
